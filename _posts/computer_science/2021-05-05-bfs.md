---
layout: post
title: "bfs(breadth-first search)"
date: 2021-05-05
excerpt: "bfs(breadth-first search)について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "bfs", "breadth-first search"]
comments: false
---

# bfs(breadth-first search)について
 - 幅優先探索のこと
 - [dfs](/dfs/)が発見したノードから探索を行うのに比べて、発見を時系列順で探索する
     - bfsの性質を利用すると最も近い経路の探索が可能である

## 例; 最短経路を求めよ

**問題**  
[No.1473 おでぶなおばけさん 解説](https://yukicoder.me/problems/no/1473)  

**回答**  
```python
from collections import deque

que = deque([(0,0)])
visited = [-1]*n

while que:
    node, value = que.popleft() # queはFIFO
    if visited[node] >= 0:
        continue
    visited[node] = value
    for next, tmp in edge[node]:
        if visited[next] == -1: # まだ未踏のノードであれば
            que.append((next,value+1)) # 自分の値に+1してqueに入れる

print(visited[-1])
```

## 例; 最短経路を求めよ(最短経路から解が導出できる)

**問題**  
[AtCoder Beginner Contest 088; D - Grid Repainting](https://atcoder.jp/contests/abc088/tasks/abc088_d)  

**回答**  
```python
import collections
import math
H,W=map(int,input().split())
G=[list(input()) for h in range(H)]
que = collections.deque([(0,0)])
dp = [[-math.inf]*W for h in range(H)]
dp[0][0] = 0
def bfs():
    while que:
        cur = que.popleft()
        for a,b in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nh = cur[0] + a
            nw = cur[1] + b
            if nh > H-1 or nh < 0 or nw < 0 or nw > W-1:
                continue
            if G[nh][nw] == "#":
                continue
            if dp[nh][nw] != -math.inf:
                continue
            dp[nh][nw] = dp[cur[0]][cur[1]] + 1
            que.append( (nh, nw) )
bfs()

white_num = sum(sum([1 for e in line if e == "."]) for line in G)
if dp[H-1][W-1] != -math.inf:
    print(white_num - dp[H-1][W-1] - 1)
else:
    print(-1)
```
