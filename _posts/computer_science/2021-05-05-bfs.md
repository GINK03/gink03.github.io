---
layout: post
title: "bfs(breadth-first search)"
date: 2021-05-05
excerpt: "bfs(breadth-first search)について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "bfs", "breadth-first search"]
comments: false
---

# bfs(breadth-first search)について
 - 幅優先探索のこと
 - [dfs](/dfs/)が発見したノードから探索を行うのに比べて、発見を時系列順で探索する
     - bfsの性質を利用すると最も近い経路の探索が可能である
 - 注意; 
     - ネットワークをstrで表現するとpypyだと非常に遅いので別途intで表現する必要がある
 - 少し改良することで`0-1 bfs`と呼ばれるコストが01で表現される際のネットワークでも最小コストを求めることができる
     - bfsは通常、FIFOであるが、コストがある経路のみをFILOにすることでなるべく通らずに到達可能な経路を探索することができる

## 例; 最短経路を求めよ

**問題**  
[No.1473 おでぶなおばけさん 解説](https://yukicoder.me/problems/no/1473)  

**回答**  
```python
def bfs(max_w):
    que = collections.deque([(0,0)]) # index, something val
    visited = [-1]*N
    while que:
        i, c = que.popleft() # queはFIFO
        if visited[i] >= 0:
            continue
        visited[i] = c
        for j, d in G[i]:
            if visited[j] == -1 and max_w <= d: # まだ未踏のノードであれば
                que.append((j,c+1)) # 自分の値に+1してqueに入れる
    return visited[-1]
```

## 例; 最短経路を求めよ(最短経路から解が導出できる)

**問題**  
[AtCoder Beginner Contest 088; D - Grid Repainting](https://atcoder.jp/contests/abc088/tasks/abc088_d)  

**回答**  
```python
import collections
import math
H,W=map(int,input().split())
G=[list(input()) for h in range(H)]
que = collections.deque([(0,0)])
dp = [[-math.inf]*W for h in range(H)]
dp[0][0] = 0
def bfs():
    while que:
        cur = que.popleft()
        for a,b in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nh = cur[0] + a
            nw = cur[1] + b
            if nh > H-1 or nh < 0 or nw < 0 or nw > W-1:
                continue
            if G[nh][nw] == "#":
                continue
            if dp[nh][nw] != -math.inf:
                continue
            dp[nh][nw] = dp[cur[0]][cur[1]] + 1
            que.append( (nh, nw) )
bfs()

white_num = sum(sum([1 for e in line if e == "."]) for line in G)
if dp[H-1][W-1] != -math.inf:
    print(white_num - dp[H-1][W-1] - 1)
else:
    print(-1)
```

## 例; 0-1 bfsの適応例; 01で表現されるコストが存在する場合の最小コスト

**問題**  
[AtCoder Regular Contest 005; C - 器物損壊！高橋君](https://atcoder.jp/contests/arc005/tasks/arc005_3)  

**回答**  
```python
import collections

H, W = map(int, input().split())

G = []
for h in range(H):
    G.append(list(input()))

for h in range(H):
    for w in range(W):
        if G[h][w] == 's':
            sh, sw = h, w
        if G[h][w] == 'g':
            gh, gw = h, w

P = [[-1] * W for _ in range(H)]
P[sh][sw] = 0

que = collections.deque([(sh, sw)])

while que:
    h, w = que.popleft()
    for dh, dw in [(-1, 0), (0, -1), (1, 0), (0, 1)]:
        nh = dh + h
        nw = dw + w
        if not (0 <= nh < H and 0 <= nw < W and P[nh][nw] == -1):
            continue
        if G[nh][nw] == '#':
            P[nh][nw] = P[h][w] + 1
            que.append((nh, nw))
        elif G[nh][nw] in {".", "g"}:
            P[nh][nw] = P[h][w]
            que.appendleft((nh, nw))

print("YES" if P[gh][gw] <= 2 else "NO")
```
