---
layout: post
title: "greedy"
date: 2020-11-15
excerpt: "greedyアルゴリズムについて"
project: false
config: true
computer_science: true
hide_from_post: true
tag: ["greedy", "algorithm"]
comments: false
---


# greedyアルゴリズムについて

## 概要
 - 現在が良ければ未来も良いはず、という一部のスケジューリング問題に基づく
   - 短期的な最大となる行動を積み重ねると、最適値につくと期待できる場合に使えるアルゴリズム
   - 制約; 途中から使用可能になったタスクは消化しない限り実行不能になることはない、という条件が必要
 - 証明
   - あるときに最良の選択をしなかった場合、後日、最良の選択をした場合と交換可能である
   - あるときに最良の選択をしなかった場合、後日、最良の選択を選べないまま終える可能性がある(= より良い選択があるのに選べないで終わる)

--- 

### 例; 典型的な例(現在選べる最大の効用を選択)

**問題**  
[第二回 アルゴリズム実技検定; F - タスクの消化](https://atcoder.jp/contests/past202004-open/tasks/past202004_f)  

**回答**  
```python
N = int(input())

X = []
for i in range(N):
    X.append([])

for i in range(N):
    a, b = list(map(int, input().split()))
    X[a - 1].append(b)

cnt = [0] * 101
ans = 0

for d in range(N):
	# d日までのポイントの大きさをカウント
    for b in X[d]:
        cnt[b] += 1
	# 最大のものを一つ選びデクリメント
    for b in range(100, 0, -1):
        if cnt[b] > 0:
            ans += b
            cnt[b] -= 1
            break
    print(ans)
```

---

### 例; 締切と所要時間があるときすべてのタスクを処理できるかどうか

**問題**  
[AtCoder Regular Contest 092; C - 2D Plane 2N Points](https://atcoder.jp/contests/arc092/tasks/arc092_a)  

**考え方**  
 - 締切が近いものからやっていく
   - 締切が近いものからやなかったときは破綻する条件がある = 締切が近いものから埋めれば良い

**回答**  
```python
N = int(input())
AB=[list(map(int, input().split())) for _ in range(N)]
AB.sort(key=lambda x:x[1])

acc = 0
for a, b in AB:
    acc += a
    if b < acc:
        print("No")
        exit()
print("Yes")
```

---

### 例; 複数の大きさの異なる箱に、価値と大きさが異なる荷物を詰めるとき、どの入れ方ならば最適か  

**問題**  
[AtCoder Beginner Contest 195; D - Shipping Center](https://atcoder.jp/contests/abc195/tasks/abc195_d)  

**考え方**  
 - ２つ指標がある
   - 価値が大きいものからその価値の荷物が入る最小の箱を探す
   - 小さな箱から見ていき、その箱に入る最大の価値の荷物を入れる

**回答**  
 - [colab](https://colab.research.google.com/drive/1MRhuN2TKHgHGY6WaU_F6QiRH4inwhBjz?usp=sharing)
---

## 例; 特殊な指標を定義する
 - [different-strokes](/different-strokes)

---

## 例; 二次元の差分でペアを作るとき最大の数になるようにペアを作る
 - [AtCoder Regular Contest 092; C - 2D Plane 2N Points](https://atcoder.jp/contests/arc092/tasks/arc092_a)
 - ***考え方***
   - ソートした上で、あるペアを`(r_a, b_b)`と`(r_b, b_a)`というペアがあったとき、`r_a < r_b`ならば交換可能であり、`(r_a, b_a)`と`(r_b, b_b)`とすることができるが、逆はできないことがある
	 - 青い点より x, y 座標が小さく，まだ仲良しペアになっていない赤い点を探す
	 - なかったらなにもしない
	 - あったら，その中で最もy座標が大きいものを探し，仲良しペアにする

## 例
 - [yukicoder No.1205 Eye Drops](https://yukicoder.me/problems/no/1205)

## 例; コインの表現

```console
Problem Description
Task. The goal in this problem is to find the minimum number of coins needed to change the input value (an integer) into coins with denominations 1, 5, and 10.
Input Format. The input consists of a single integer 𝑚.
Constraints. 1 ≤ 𝑚 ≤ 103.
Output Format. Output the minimum number of coins with denominations 1, 5, 10 that changes 𝑚.
```
 - コインを大きいものから割り枚数を求める点がgreedy

## 例; fractional knapsack

```console
Problem Description
Task. The goal of this code problem is to implement an algorithm for the fractional knapsack problem.
Input Format. The first line of the input contains the number 𝑛 of items and the capacity 𝑊 of a knapsack. The next 𝑛 lines define the values and weights of the items. The 𝑖-th line contains integers 𝑣𝑖 and 𝑤𝑖—the value and the weight of 𝑖-th item, respectively.
Constraints. 1≤𝑛≤103,0≤𝑊 ≤2·106;0≤𝑣𝑖 ≤2·106,0<𝑤𝑖 ≤2·106 forall1≤𝑖≤𝑛.Allthe numbers are integers.
Output Format. Output the maximal value of fractions of items that fit into the knapsack. The absolute value of the difference between the answer of your program and the optimal value should be at most 10−3. To ensure this, output your answer with at least four digits after the decimal point (otherwise your answer, while being computed correctly, can turn out to be wrong because of rounding issues)
```
 - 価値が大きいものから詰められるだけ詰めるのがgreedy

## 例; 最大の値を組み合わせで作る

```console

Problem Introduction
You are organizing a funny competition for children. As a prize fund you have 𝑛 candies. You would like to use these candies for top 𝑘 places in a competition with a natural restriction that a higher place gets a larger number of candies. To make as many children happy as possible, you are going to find the largest value of 𝑘 for which it is possible.
Problem Description
Task. The goal of this problem is to represent a given positive integer 𝑛 as a sum of as many pairwise distinct positive integers as possible. That is, to find the maximum 𝑘 such that 𝑛 can be written as 𝑎1+𝑎2+···+𝑎𝑘 where𝑎1,...,𝑎𝑘 arepositiveintegersand𝑎𝑖 ̸=𝑎𝑗 forall1≤𝑖<𝑗≤𝑘.
Input Format. The input consists of a single integer 𝑛.
Constraints. 1 ≤ 𝑛 ≤ 109.
Output Format. In the first line, output the maximum number 𝑘 such that 𝑛 can be represented as a sum of 𝑘 pairwise distinct positive integers. In the second line, output 𝑘 pairwise distinct positive integers that sum up to 𝑛 (if there are many such representations, output any of them).
```
 - 最小のものに比べて最大となる要素はどれか、をすべての要素について捜査しランク付けするのがgreedy
