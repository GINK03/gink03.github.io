---
layout: post
title: "prime"
date: 2021-05-18
excerpt: "素因数分解,素数列挙について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "math", "integer", "prime"]
comments: false
---

# 素因数分解について
テンプレートになっている  
`10^9`ぐらいまで行ける  

## nの素因数分解

```python
def prime_factorize(n):
    a = []
    while n % 2 == 0:
        a.append(2)
        n //= 2
    f = 3
    while f * f <= n:
        if n % f == 0:
            a.append(f)
            n //= f
        else:
            f += 2
    if n != 1:
        a.append(n)
    return a
```

## 例; 約数の個数を求める
**問題**  
[AtCoder Beginner Contest 052; C - Factors of Factorial](https://atcoder.jp/contests/abc052/tasks/arc067_a)  
**解説**  
素因数分解をし`S=p1^n1*p2^n2*...`という結果が得られたとき、約数の個数は`(n1+1)*(n2+1)*...`である  
**解答**  
 - [submission](https://atcoder.jp/contests/abc052/submissions/22707282)

# 素数列挙について
エラトステネスの篩でできる  
やっていることはdpを使っての計算量削減  

```python
def sieve(n):
    dp = [1]*(n+1) # 初期値ですべてを素数と仮定
    dp[0] = 0; dp[1] = 0
    for i in range(2, n+1):
        if dp[i]: # もし素数ならば
            j = 2 * i # iの倍数はすべて素数ではないはず
            while j <= n:
                dp[j] = 0
                j += i 
    return [i for i in range(n) if dp[i]] 
```
 - [colab](https://colab.research.google.com/drive/1Y20HOWxadh9mcOlrumNRV7YzK8QLUK4D?usp=sharing)

# Nまでの数字のすべての数の素因数分解を行う  
```python
import collections
import math
def sieve_div(n):
    dp = [1]*(n+1) # 初期値ですべてを素数と仮定
    dp[0] = 0; dp[1] = 0
    divs = collections.defaultdict(list)
    for i in range(2, n+1):
        if dp[i]: # もし素数ならば
            divs[i].append(i)
            j = 2 * i # iの倍数はすべて素数ではないはず
            while j <= n:
                dp[j] = 0
                divs[j].append( i )
                j += i 
    return divs
print(sorted(sieve_div(100).items())) # [(2, [2]), (3, [3]), (4, [2]), (5, [5]), (6, [2, 3]), (7, [7]), (8, [2]), (9, [3]), (10, [2, 5]), ...
```
**例題**  
 - [AtCoder Beginner Contest 177](https://atcoder.jp/contests/abc177/tasks/abc177_e)

## 例; エラトステネスの篩の応用(お互いに割り切れない数を求める)  

**問題**  
[AtCoder Beginner Contest 170; D - Not Divisible](https://atcoder.jp/contests/abc170/tasks/abc170_d)  

**解説**  
やり方はエラトステネスの篩の櫛と同じであるが素数でないのでそこまで最適化されない  
dpっぽいテーブルを使って解くことで解くことができる  

**説明**  

```python
def sieve(arr):
    max_ = max(arr)
    is_baisu = [0 for _ in range(max_+1)]

    for a in arr:
        is_baisu[a] += 1
        for b in range(a*2, max_+1, a):
            is_baisu[b] += 1
    cnt = 0
    for a in arr:
        # is_baisu[a] == 1であることは、一度しかその変数で作られておらず、他の数の倍数で表現できないということ
        if is_baisu[a] == 1:
            cnt += 1
    print(cnt)

N=input()
A=list(map(int,input().split()))
sieve(A)
```
