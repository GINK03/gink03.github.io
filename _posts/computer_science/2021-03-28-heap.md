---
layout: post
title: "heapについて"
date: 2021-03-27
excerpt: "heapについて"
computer_science: true
hide_from_post: true
tag: ["algorithm", "data structure", "データ構造", "heap"]
comments: false
---

# heapについて
heapはソートされた状態で要素の追加削除(多くはO(log n))を行うアルゴリズムである  
多くの場合は二分木を内部的木に構成しており、これによる逐次的なソートの計算を省略することが可能である  

## ランダウ表記
<div>
  <img src="https://user-images.githubusercontent.com/4949982/112731480-d3600700-8f7a-11eb-8984-b83073966072.png">
</div>

## pythonでの利用例

```python
>>> from heapq import heappush, heappop
>>> h = []
>>> heappush(h, (5, 'write code'))
>>> heappush(h, (7, 'release product'))
>>> heappush(h, (1, 'write spec'))
>>> heappush(h, (3, 'create tests'))
>>> heappop(h)
(1, 'write spec')
>>> heappop(h)
(3, 'create tests')
>>> heappop(h)
(5, 'write code')
>>> heappop(h)
(7, 'release product')
```

## ヒープソートの例

```python
>>> def heapsort(iterable):
...     h = []
...     for value in iterable:
...         heappush(h, value)
...     return [heappop(h) for i in range(len(h))]
...
>>> heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 値が存在しているかのチェック

```python
>> "any value" in pq
```
 - heapはlog(1)で値のチェックができそうであるが、検索時は`in`を使うと線形探索になるのでとても遅い
   - [colab](https://colab.research.google.com/drive/1tYihDe7bjPLb9GhyAH9AGGwKp51d4R6I?usp=sharing) 

## 例; heapを使うことで順序付きリストを高速に管理する  

[No.1439 Let's Compare!!!!](https://yukicoder.me/problems/no/1439)

```python
import heapq
import collections
N = int(input())
S = list(map(int, list(input())))
T = list(map(int, list(input())))
Q = int(input())
que = collections.deque()
pq = []
heapq.heapify(pq)
for i, (s, t) in enumerate(zip(S, T)):
    if s != t:
        heapq.heappush(pq, i)

for q in range(Q):
    flag, s, v = input().split()
    s = int(s)-1
    v = int(v)
    if flag == "S":
        S[s] = v
    else:
        T[s] = v
    if S[s] != T[s]:
        heapq.heappush(pq, s)

    tmp = "="
    while pq:
        cur = heapq.heappop(pq)
        if S[cur] > T[cur]:
            tmp = ">"
            heapq.heappush(pq, cur)
            break
        elif S[cur] == T[cur]:
            continue
        elif S[cur] < T[cur]:
            tmp = "<"
            heapq.heappush(pq, cur)
            break
    que.append(tmp)
while que:
    print(que.popleft())
```
