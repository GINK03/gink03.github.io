---
layout: post
title: "しゃくとり法"
date: 2021-05-19
excerpt: "しゃくとり法(two pointers)について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "math", "two ponters"]
comments: false
---

# しゃくとり法(two pointers)について
 - ある基準を満たす区間を走査する場合、AからBまでを変数にして全区間をみると`O(n^2)`の計算量がかかってしまう
 - A(left)が広義単調増加関数として扱えるときしゃくとり法が使え計算量が`O(n)`になる

 - **参考**
   - [しゃくとり法 (尺取り法) の解説と、それを用いる問題のまとめ](https://qiita.com/drken/items/ecd1a472d3a0e7db8dce)

## python

```python
right = 0     
for left in range(0,n):
    while right < n and (rightを1個進めたときに条件を満たす)):
	    # 実際にrightを1進める
		# ex: sum += a[right]
        right += 1

	# break した状態で right は条件を満たす最大なので、何かする
	# ex: res += (right - left)

	# left をインクリメントする準備 
	# ex: if (right == left) right += 1
	# ex: else sum -= a[left]
```

## 例; 掛け算のしゃくとり法
**問題**  
[AtCoder Beginner Contest 032; C - 列](https://atcoder.jp/contests/abc032/tasks/abc032_c)  

**解答**  

```python
N,K=map(int,input().split())

S=[]
for _ in range(N):
    S.append(int(input()))
if S.count(0) != 0:
    print(N)
    exit()

right = 0
calc = 1
ans = 0
for left in range(0,N):
    while right < N:
        if S[right]*calc <= K:
            calc *= S[right]
            ans = max(ans, right-left+1)
            #print(left, right, calc)
            right += 1
        else:
            break
    # leftがrightに追いついてしまったら
    # rightをインクリメントする
    # (これを入れ忘れると間違う)
    if left == right:
        right += 1
    else:
        # インクリメント時に前の情報を消す
        calc /= S[left]
print(ans)
```
