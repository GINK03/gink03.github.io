---
layout: post
title: "しゃくとり法"
date: 2021-05-19
excerpt: "しゃくとり法(two pointers)について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "math", "two ponters"]
comments: false
---

# しゃくとり法(two pointers)について
 - ある基準を満たす区間を走査する場合、AからBまでを変数にして全区間をみると`O(n^2)`の計算量がかかってしまう
 - A(left)が広義単調増加関数として扱えるときしゃくとり法が使え計算量が`O(n)`になる

 - **参考**
   - [しゃくとり法 (尺取り法) の解説と、それを用いる問題のまとめ](https://qiita.com/drken/items/ecd1a472d3a0e7db8dce)
 - ２つのリストの要素間の最小値を求める等にも使える

## python

**テンプレート1**  
 - 一般化しやすい

```python
N=int(input())
*A,=map(int,input().split())

ans = 0
left, right = 0, 0
tmp = set()
while left < N and right < N:
    if A[right] not in tmp: # 満たすか
        tmp.add(A[right])
        right += 1
        ans = max(len(tmp), ans)
    else:
        tmp.remove(A[left])
        left += 1
        if left > right:
            right = left
print(ans)
```

**テンプレート2**  
 - `segment tree`を使う方法
 - かんたんに一般化できる

```python
N,K=map(int,input().split())
S=[int(input()) for _ in range(N)]
 
if S.count(0) > 0:
    print(N); exit()
 
stree = Segtree(V=S, OP=lambda x,y:x*y, E=1)
ans = 0
left, right =0, 0
while left < N and right < N:
    if stree.prod(left, right+1) <= K:
        ans = max(ans, right - left + 1)
        right += 1
    else:
        left += 1
        if left > right:
            right = left
print(ans)
```

**テンプレート3**  
```python
right = 0     
for left in range(0,n):
    while right < n and (rightを1個進めたときに条件を満たす)):
        # 実際にrightを1進める
        # ex: sum += a[right]
        right += 1

    # break した状態で right は条件を満たす最大なので、何かする
    # ex: res += (right - left)

    # left をインクリメントする準備 
    # ex: if (right == left) right += 1
    # ex: else sum -= a[left]
```

## 例; 掛け算のしゃくとり法
**問題**  
[AtCoder Beginner Contest 032; C - 列](https://atcoder.jp/contests/abc032/tasks/abc032_c)  

**解答**  

```python
N,K=map(int,input().split())

S=[]
for _ in range(N):
    S.append(int(input()))
if S.count(0) != 0:
    print(N)
    exit()

right = 0
calc = 1
ans = 0
for left in range(0,N):
    while right < N:
        if S[right]*calc <= K:
            calc *= S[right]
            ans = max(ans, right-left+1)
            #print(left, right, calc)
            right += 1
        else:
            break
    # leftがrightに追いついてしまったら
    # rightをインクリメントする
    # (これを入れ忘れると間違う)
    if left == right:
        right += 1
    else:
        # インクリメント時に前の情報を消す
        calc /= S[left]
print(ans)
```

## 例; ２つのリストの要素の最小値を求める
**問題**  
[NOMURA プログラミングコンテスト 2021(AtCoder Regular Contest 121)](https://atcoder.jp/contests/arc121/tasks/arc121_b)  
**解説**  
計算量を`O(N^2)`から`O(2N)`に変換することができる  
```python
A = [i for i in range(10**4) if random.random() <= 0.1 ]
B = [i for i in range(10**4) if random.random() <= 0.1 ]
i, j = 0, 0
ans = 0
while i < len(A) and j < len(B):
    ans = min(ans, abs(A[i] - B[j]))
    if A[i] > B[j]:
        j += 1
    else:
        i += 1
print(ans)
```
 - [実験コード](https://colab.research.google.com/drive/1DHmEKyQNlgvxqHQQHQVMuBB3as413Eds?usp=sharing)

**解答**  
[submission](https://atcoder.jp/contests/arc121/submissions/23019601)
