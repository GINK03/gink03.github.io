---
layout: post
title: "dijkstra"
date: 2021-04-25
excerpt: "ダイクストラ法について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "network", "dijkstra", "ダイクストラ法"]
comments: false
---

# ダイクストラ法(dijkstra)について
 - 幅優先探索、深さ優先探索以外の、コスト付き(優先度付き)探索である
 - 優先度の並び替えに計算量が`O(log N)`の`heapキュー`を用いる
   - よくある展開として、最もコストが安い順にネットワークをたどるなど

---

### 例; 典型的な最短経路問題
**問題**  
[典型アルゴリズム問題集; D - 単一始点最短経路問題](https://atcoder.jp/contests/typical-algorithm/tasks/typical_algorithm_d)  
**解説**  
経路の長さが`c`のパラメータで与えられた場合  
**回答**  
```python
import heapq

N, M = map(int, input().split())
G = [[] for _ in range(N)]

for _ in range(M):
    u, v, c = map(int, input().split())
    G[u].append((v,c))
 
dist = [-1 for _ in range(N)]
dist[0] = 0
Q = []
heapq.heappush(Q, (0,0)) # 距離d, 頂点iの順
done = [False for _ in range(N)]
 
while len(Q) > 0:
    d, i = heapq.heappop(Q)
    # すでに訪れたところは処理しない
    if done[i]:
        continue
    done[i] = True
    for j, c in G[i]:
        # 評価が未知のエッジ or より安くなる可能性がある場合は探索し、結果をヒープに入れる
        if dist[j] == -1 or dist[j] > dist[i] + c:
            dist[j] = dist[i] + c
            heapq.heappush(Q, (dist[j], j))
print(dist[N-1])
```

---

### 例; 折返しのある最短経路問題(行って戻ってくるまでの最短経路)
**問題**  
[AtCoder Beginner Contest 191; E - Come Back Quickly](https://atcoder.jp/contests/abc191/tasks/abc191_e)  
**解説**  
 - 折返しがあるので有方向でグラフを定義する 
 - 一度たどった道かどうかを管理するのではなく、何回通ったかを管理する(管理しなくても解けるが計算量が大幅に増える)
**回答**  
```python
import collections
import heapq
import math

N,M=map(int,input().split())
G = collections.defaultdict(list)

for _ in range(M):
    u, v, c = map(int, input().split())
    G[u-1].append((v-1,c))

for n in range(N):
    dist = [math.inf for _ in range(N)]
    Q = []
    heapq.heappush(Q, (0,n)) # 距離d, 頂点iの順
    flag = True
    nums = [0]*N
    while Q:
        d, i = heapq.heappop(Q)
        # 帰り際であったら終了する
        if i == n and d > 0:
            print(d)
            flag = False
            break
        # 行き帰りで二回だからたかだか二回に限定する
        if nums[i] >= 2:
            continue
        nums[i] += 1
        for j, c in G[i]:
            # より安くなる可能性がある場合は探索し、ノードをヒープに入れる
            if dist[j] > d + c:
                dist[j] = d + c
                heapq.heappush(Q, (dist[j], j))
    if flag:
        print(-1)
```

--- 

### 例; 最大許容積載量

**問題**  
[No.1473 おでぶなおばけさん](https://yukicoder.me/problems/no/1473)  
**解説**  
各通路の最大積載量をマイナスし、経路のコストを足し合わせる代わりに、最大のコスト(つまり最小の積載量)を次に繋げる  

```python
from heapq import heappop,heappush
n,m=map(int,input().split())
edge=[[] for i in range(n)]
for i in range(m):
    s,t,d=map(int,input().split())
    s-=1;t-=1
    edge[s].append((t,d*-1)) # マイナスする
    edge[t].append((s,d*-1)) 
def dijkstra(s,n,edge):
    inf=float("inf")
    ans=[inf]*n
    ans[s]=0
    root=[0]*n
    open=[[-inf,s]]
    while open:
        cost,node=heappop(open)
        if ans[node]<cost:
            continue
        for next,e_cost in edge[node]:
            if max(cost,e_cost)<ans[next]:
                ans[next]=max(cost,e_cost) # 次と今の最小の許容量を保存する
                root[next]=root[node]+1
                heappush(open,[max(cost,e_cost),next]) # ヒープにプッシュする値も最小の許容量
    return ans[-1]*-1
border=dijkstra(0,n,edge)
```
