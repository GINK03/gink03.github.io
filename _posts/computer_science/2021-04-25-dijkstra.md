---
layout: post
title: "dijkstra"
date: 2021-04-25
excerpt: "ダイクストラ法について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "network", "dijkstra", "ダイクストラ法"]
comments: false
---

# ダイクストラ法(dijkstra)について
 - 幅優先探索、深さ優先探索以外の、コスト付き(優先度付き)探索である
 - 優先度の並び替えに計算量が`O(log N)`の`heapキュー`を用いる
   - よくある展開として、最もコストが安い順にネットワークをたどるなど
   - わんちゃんbfsを2分探索したほうが計算コストが安いこともあり、適応を見極める必要がある

---

### 例; 典型的な最短経路問題
**問題**  
[典型アルゴリズム問題集; D - 単一始点最短経路問題](https://atcoder.jp/contests/typical-algorithm/tasks/typical_algorithm_d)  
**解説**  
経路の長さが`c`のパラメータで与えられた場合  
**回答**  

```python
import heapq

N, M = map(int, input().split())
G = [[] for _ in range(N)]

for _ in range(M):
    u, v, c = map(int, input().split())
    G[u].append((v,c))
 
dist = [-1 for _ in range(N)]
dist[0] = 0
Q = []
heapq.heappush(Q, (0,0)) # 距離d, 頂点iの順
done = [False for _ in range(N)]
 
while len(Q) > 0:
    d, i = heapq.heappop(Q)
    # すでに訪れたところは処理しない
    if done[i]:
        continue
    done[i] = True
    for j, c in G[i]:
        # 評価が未知のエッジ or より安くなる可能性がある場合は探索し、結果をヒープに入れる
        if dist[j] == -1 or dist[j] > dist[i] + c:
            dist[j] = dist[i] + c
            heapq.heappush(Q, (dist[j], j))
print(dist[N-1])
```

---

### 例; 折返しのある最短経路問題(行って戻ってくるまでの最短経路)
**問題**  
[AtCoder Beginner Contest 191; E - Come Back Quickly](https://atcoder.jp/contests/abc191/tasks/abc191_e)  

**解説**  
 - 折返しがあるので有方向でグラフを定義する 
 - 一度たどった道かどうかを管理するのではなく、何回通ったかを管理する(管理しなくても解けるが計算量が大幅に増える) 

**回答**  

```python
import collections
import heapq
import math

N,M=map(int,input().split())
G = collections.defaultdict(list)

for _ in range(M):
    u, v, c = map(int, input().split())
    G[u-1].append((v-1,c))

for n in range(N):
    dist = [math.inf for _ in range(N)]
    Q = []
    heapq.heappush(Q, (0,n)) # 距離d, 頂点iの順
    flag = True
    nums = [0]*N
    while Q:
        d, i = heapq.heappop(Q)
        # 帰り際であったら終了する
        if i == n and d > 0:
            print(d)
            flag = False
            break
        # 行き帰りで二回だからたかだか二回に限定する
        if nums[i] >= 2:
            continue
        nums[i] += 1
        for j, c in G[i]:
            # より安くなる可能性がある場合は探索し、ノードをヒープに入れる
            if dist[j] > d + c:
                dist[j] = d + c
                heapq.heappush(Q, (dist[j], j))
    if flag:
        print(-1)
```

--- 

### 例; 最大許容積載量

**問題**  
[No.1473 おでぶなおばけさん](https://yukicoder.me/problems/no/1473)  
**解説**  
各通路の最大積載量をマイナスし、経路のコストを足し合わせる代わりに、最大のコスト(つまり最小の積載量)を次に繋げる  

```python
def dijkstra():
    weights = [None for _ in range(N)]
    que = []
    heapq.heapify(que)
    heapq.heappush(que, (math.inf, 0)) # weight, index
    nums = [0]*N
    while que:
        '''
        aw: accumlated weight
        nw: next weight
        '''
        aw, i = heapq.heappop(que)
        if weights[i] and aw <= weights[i]:
            continue
        weights[i] = aw
        for j, nw in G[i]:
            nw = min(aw, nw)
            heapq.heappush(que, (nw, j))
    ans = weights[N-1]
    return ans
```

### 例; greedyっぽさがある最短経路問題

**問題**  
[AtCoder Beginner Contest 192; E - Train](https://atcoder.jp/contests/abc192/tasks/abc192_e)  

**解説**  
特定の倍数のときだけ通れるということであるが、シンプルに累積コストを計算しておき、累積コストが小さいものから順に見ていく  

```python
import collections
import heapq
import math

N,M,X,Y=map(int,input().split())
X-=1
Y-=1

G = collections.defaultdict(list)

for _ in range(M):
    A,B,T,K = map(int, input().split())
    G[A-1].append((B-1,T,K))
    G[B-1].append((A-1,T,K))

cost = [math.inf for _ in range(N)]
que = []
heapq.heapify(que)
heapq.heappush(que, (0, X)) # コスト
nums = [0]*N
while que:
    '''
    ac: accumlated cost
    nc: next cost
    '''
    ac, i = heapq.heappop(que)
    if ac > cost[i]:
        continue
    cost[i] = ac

    for j, t, k in G[i]:
        nc = ac
        if ac%k != 0:
            nc += k - ac%k
        nc += t
        heapq.heappush(que, (nc, j))

if cost[Y] is math.inf:
    print(-1)
else:
    print(cost[Y])
```

---

### 例; 典型的なdijkstra適応例
**問題**  
[第７回日本情報オリンピック 予選（過去問）;F - 船旅](https://atcoder.jp/contests/joi2008yo/tasks/joi2008yo_f)  

**解答**  

```python
import heapq

def dijkstra(s, t, G):
    dist = [float('inf') for _ in range(N)]
    dist[s] = 0
    que = []
    heapq.heapify(que)
    heapq.heappush(que, (0,s)) # 距離d, 頂点iの順
    done = [False for _ in range(N)]
    while que:
        d, i = heapq.heappop(que)
        # すでに訪れたところは処理しない
        if done[i]:
            continue
        done[i] = True
        for j, c in sorted(G[i]):
            # 評価が未知のエッジ or より安くなる可能性がある場合は探索し、結果をヒープに入れる
            if dist[j] > dist[i] + c:
                dist[j] = dist[i] + c
                heapq.heappush(que, (dist[j], j))
    print(dist[t] if dist[t] != float('inf') else -1)

N, K = map(int, input().split())
G = [[] for _ in range(N)]
Q = []
for _ in range(K):
    lst = list(map(int, input().split()))
    if lst[0] == 0:
        a, s, t = lst
        s-=1
        t-=1
        dijkstra(s,t,G)
    else:
        a, s, t, w = lst
        s-=1
        t-=1
        G[s].append((t, w))
        G[t].append((s, w))

```
