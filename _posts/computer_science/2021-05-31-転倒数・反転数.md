---
layout: post
title: "転倒数・反転数"
date: 2021-05-31
excerpt: "転倒数・反転数について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "math", "転倒数", "反転数"]
comments: false
---

# 転倒数・反転数について

連続する整数を何回入れ替えると(=バブルソートすると)昇順に並ぶのかをカウントする  

bidを用いたdpのようなことをして計算量を`O(n^2)`から`O(n log n)`にする  

## 基本的な考え方

数字をbitで表現すると大小を少ない回数(ビットのフラグだけ)の操作で、ある値以上、ある値以下の出現回数のdpを作成することができる  

`k`という数字をシフトするのに`k + (k & -k)`という操作を用いる  

具体的な挙動のイメージを掴むのに[google colab](https://colab.research.google.com/drive/16BlTkjAwajxSRW_K6QnFHetP-nUy2AsT?usp=sharing)を用意した  

## pythonでの実装例

```python
N = 6
A = [2,1,3,5,4,6]

class BIT:
    def __init__(self, N):
        self.data = [0]*(N+1)
    def add(self, k, x):
        data = self.data
        while k <= N:
            data[k] += x
            k += k & -k
    def get(self, k):
        data = self.data
        s = 0
        while k:
            s += data[k]
            k -= k & -k
        return s
b = BIT(N=N)

ans = 0
for i, a in enumerate(A):
    # 自分より小さい要素がいくつ存在するかを計算
    ans += (N-1-i) - b.get(a)
    b.add(a, 1)
print(ans) # 2
```

## 参考
 - [反転数](https://tjkendev.github.io/procon-library/python/sequence/number_of_inversions.html)
