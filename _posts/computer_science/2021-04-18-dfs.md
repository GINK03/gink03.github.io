---
layout: post
title: "dfs(depth-first search)"
date: 2021-04-18
excerpt: "dfs(depth-first search)について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "dfs", "depth-first search"]
comments: false
---

# dfs(depth-first search)について
 - 深さ優先探索
 - カスタマイズすることでノードがつながった数のカウント等にも使える


## 具体的なサンプルコード

```python
import collections
# Using a Python dictionary to act as an adjacency list
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F', 'A'],
    'D': [],
    'E': ['F'],
    'F': ['X'],
    'X': ['A', 'Y'],
    'Y': ['Z'],
    'Z': []
}

traces = [] # デバッグ用にどの経路をたどって探索したか
def dfs(visited: set, graph: dict, nodes: collections.deque):
    while nodes:
        node = nodes.pop()
        if node not in visited:
            traces.append(node)
            visited.add(node)
            for node_ in graph[node]:
                nodes.append(node_)


visited = set()  # Set to keep track of visited nodes.
nodes = collections.deque(["A"])
dfs(visited, graph, nodes)
print(traces) # ['A', 'C', 'F', 'X', 'Y', 'Z', 'B', 'E', 'D']
```

---

## 具体的な問題とその回答
 - [Finding an Exit from a Maze](/finding-an-exit-from-a-maze)
 - [Adding Exits to a Maze](/adding-exists-to-a-maze)

---

## 例; AtCoder Typical Contest 001; A - 深さ優先探索
**問題**  
[AtCoder Typical Contest 001; A - 深さ優先探索](https://atcoder.jp/contests/atc001/tasks/dfs_a)  
**解説**  
典型的なdfsによるソリューション  
**回答**  
 - [colab](https://colab.research.google.com/drive/1H91Xgt0B7ITR9ozKhqRGyl8bH_5FqfLz?usp=sharing)

---

## 例; 接続したノードの数のカウントアルゴリズム

**擬似コード**  
<div>
  <img src="https://user-images.githubusercontent.com/4949982/115136275-b2f70a00-a059-11eb-8cdf-09924b326905.png">
</div>

**擬似結果**  
<div>
  <img src="https://user-images.githubusercontent.com/4949982/115136344-2862da80-a05a-11eb-8e0f-4877d6997583.png">
</div>
