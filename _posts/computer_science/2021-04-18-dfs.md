---
layout: post
title: "dfs(depth-first search)"
date: 2021-04-18
excerpt: "dfs(depth-first search)について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "dfs", "depth-first search"]
comments: false
---

# dfs(depth-first search)について
 - 深さ優先探索
 - カスタマイズすることでノードがつながった数のカウント等にも使える
 - 四畳半で使われる畳(一畳と半畳の畳)で床を敷き詰めるパターンの全探索等
 - ネットワーク中の閉路の数を求める


## 具体的なサンプルコード

```python
import collections
G = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F', 'A'],
    'D': [],
    'E': ['F'],
    'F': ['X'],
    'X': ['A', 'Y'],
    'Y': ['Z'],
    'Z': []
}
traces = [] # デバッグ用にどの経路たどって探索したか
visited = set()
que = collections.deque(["A"])

def dfs():
    while que:
        i = que.pop()
        if i not in visited:
            traces.append(i)
            visited.add(i)
            for j in G[i]:
                que.append(j)

dfs()
print(traces) # ['A', 'C', 'F', 'X', 'Y', 'Z', 'B', 'E', 'D']
```

---

## 例; 具体的な例題とその回答
 - [Finding an Exit from a Maze](/finding-an-exit-from-a-maze)
 - [Adding Exits to a Maze](/adding-exists-to-a-maze)

---

## 例; AtCoder Typical Contest 001; A - 深さ優先探索
**問題**  
[AtCoder Typical Contest 001; A - 深さ優先探索](https://atcoder.jp/contests/atc001/tasks/dfs_a)  
**解説**  
典型的なdfsによるソリューション  
**回答**  
 - [colab](https://colab.research.google.com/drive/1H91Xgt0B7ITR9ozKhqRGyl8bH_5FqfLz?usp=sharing)  

---

## 例; dfsを適応するとテンプレート的に解ける問題
**問題**  
[AtCoder Beginner Contest 197; B - Visibility](https://atcoder.jp/contests/abc197/tasks/abc197_b)  
**回答**
 - [colab](https://colab.research.google.com/drive/1clXkhrx28kL9-6akDahpz9Cdk9gZHyzx?usp=sharing)

---

## 例; 畳の埋めるパターンをdfsを用いて全探索する  
**問題**  
[AtCoder Beginner Contest 196; D - Hanjo](https://atcoder.jp/contests/abc196/tasks/abc196_d)  
**回答**  
 - [colab](https://colab.research.google.com/drive/1AT8MNS6xyXdgwvFRL4M_DmmVdaSzgtvs?usp=sharing)  

---

## 例; 閉路の検出
**問題**  
[AtCoder Regular Contest 037; B - バウムテスト](https://atcoder.jp/contests/arc037/tasks/arc037_b)  

**解説**  
閉路を含む = 一つのノードに複数個の参照がある, と読み替えることができる
たどったかどうかを保存するテーブルを工夫し、一つのノードにどれくらい参照があったかをカウントすることで実現できる  

**回答**  
 - [colab](https://colab.research.google.com/drive/1TKD3KZZ4OQXMmd5uyKo2WKV09ZQbOdHP?usp=sharing)

---

## 例; 接続したノードの数のカウントアルゴリズム

**擬似コード**  
<div>
  <img src="https://user-images.githubusercontent.com/4949982/115136275-b2f70a00-a059-11eb-8cdf-09924b326905.png">
</div>

**擬似結果**  
<div>
  <img src="https://user-images.githubusercontent.com/4949982/115136344-2862da80-a05a-11eb-8e0f-4877d6997583.png">
</div>


