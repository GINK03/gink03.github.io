---
layout: post
title: "cumsum"
date: 2021-04-24
excerpt: "累積和について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "dynamic programming", "cumsum", "累積和"]
comments: false
---

# 累積和(cumsum)について
 - 別名尺取法
 - ある列があり区間の評価を行いたい場合`O(n^2)`を`O(n)`に減らす
 - 左から見た累積和のリストを構築し`O(1)`でその区間を評価できるようにする点がキモ
 - 右から見た累積和の計算が少々ややこしい
   - `(N-1-i)-(sum[N] - sum[i+1])`

## 具体例

**問題**
[出典: AtCoder Regular Contest 098](https://atcoder.jp/contests/arc098/tasks/arc098_a)  

```
N人の人が東西方向に一列に並んでいます。 それぞれの人は、東または西を向いています。 誰がどの方向を向いているかは長さ 
Nの文字列Sによって与えられます。 西からi番目に並んでいる人は、E なら東を、W なら西を向いています。

あなたは、N人のうち誰か 1人をリーダーとして任命します。 そして、リーダー以外の全員に、リーダーの方向を向くように命令します。 このとき、リーダーはどちらの方向を向いていても構いません。

並んでいる人は、向く方向を変えるのを嫌っています。 そのためあなたは、向く方向を変える人数が最小になるようにリーダーを選びたいです。 向く方向を変える人数の最小値を求めてください。
```

**回答**

```python
import math

N = int(input())
S = input()


min_turn = math.inf


sum_w = [0]

for i in range(0, N):
    if S[i] == "W":
        sum_w.append(sum_w[i]+1)
    else:
        sum_w.append(sum_w[i])

for i in range(0, N):
    # 西を無ている人の数
    w = sum_w[i]

    # 東を無ている人の数(ここの添字が複雑)
    e = (N-1-i) - (sum_w[N] - sum_w[i+1])

    # 帰る向きの数
    turn = w + e

    min_turn = min(min_turn, turn)

print(min_turn)
```

