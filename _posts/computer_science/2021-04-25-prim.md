---
layout: post
title: "prim's algorithm"
date: 2021-04-25
excerpt: "プリム法について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "network", "graph", "prim"]
comments: false
---

# プリム(prim)法について
 - 最小全域木探索アルゴリズムの一つ
 - ある支点から最もコストが安い経路を一つ選ぶ
   - この経路を追加した上で最もその中から最もコストが安いものを選ぶ
	 - `heap`で優先順位を管理しながら探索すると現実的な時間で解くことができる

## 例; 最小全域木問題

[典型アルゴリズム問題集; F - 最小全域木問題](https://atcoder.jp/contests/typical-algorithm/tasks/typical_algorithm_f)

```python
import heapq

N, M = map(int, input().split())

G = [[] for _ in range(N)]

for _ in range(M):
    u, v, c = map(int, input().split())
    G[u].append((v, c))
    G[v].append((u, c))


marked = [False] * N
count = 1
sum = 0

Q = []
for j, c in G[0]:
    heapq.heappush(Q, (c, j))
marked[0] = True


while count < N:
    c, i = heapq.heappop(Q)
    if marked[i]:
        continue
    marked[i] = True
    count += 1
    sum += c

    for (j, c) in G[i]:
        if marked[j]:
            continue

        heapq.heappush(Q, (c, j))

print(sum)
```

---

## 例; ノードの数が10^9オーダーの時
**問題**  
[AtCoder Beginner Contest 065](https://atcoder.jp/contests/abc065/tasks/arc076_b)
**解説**  
初期化のために最初にqueを作成する段階でmarkedのような到達したノードを管理する変数を連動させることを忘れがちである  
純粋に文字列をキーとして探索することもできるが、pypyでは許容できそうにない遅さになる(pypyは文字列比較等が遅い)  
**解答**  
```python
import collections
import heapq

N = int(input())
XY = [list(map(int,input().split())) + [i] for i in range(N)]
G = collections.defaultdict(list)
XY.sort()
for i in range(N-1):
    d = 1
    sx, sy, si = XY[i]
    tx, ty, ti = XY[i+d]
    c = min(abs(tx - sx), abs(ty - sy))
    G[si].append( (ti, c) )
    G[ti].append( (si, c) )
XY.sort(key=lambda x:x[1])
for i in range(N-1):
    d = 1
    sx, sy, si = XY[i]
    tx, ty, ti = XY[i+d]
    c = min(abs(tx - sx), abs(ty - sy))
    G[si].append( (ti, c) )
    G[ti].append( (si, c) )


N = len(G)
marked = set()
count = 1
sum = 0

Q = []

# 最初は手動探査
for j, c in G[0]:
    heapq.heappush(Q, (c, j))
marked.add(0)

while Q:
    c, i = heapq.heappop(Q)
    if i in marked:
        continue
    marked.add(i)
    sum += c
    for (j, nc) in G[i]:
        if j in marked:
            continue
        heapq.heappush(Q, (nc, j))
print(sum)
```
