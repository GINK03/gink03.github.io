---
layout: post
title: "lis"
date: 2021-05-18
excerpt: "最長増加部分列(longest increasing sequence)について"
computer_science: true
hide_from_post: true
tag: ["algorithm", "math", "integer", "dp", "lis", "longest increasing sequence"]
comments: false
---

# 最長増加部分列(longest increasing sequence)について

## pythonのコード

```python
import bisect

# sample input
N = 7
A = [1, 2, 1, 2, 5, 6, 3]

INF = float('inf')
dp = [INF]*(N+1)
dp[0] = -1
for a in A:
    idx = bisect.bisect(dp, a-1) # 最長増加部分列
	# idx = bisect.bisect(dp, a) # 広義最長増加部分列
    dp[idx] = min(a, dp[idx])
print(dp)
ans = max(i for i in range(N+1) if dp[i] < INF)
```

---

### 例; 広義単調減少が解答になる例
**問題**  
[AtCoder Beginner Contest 134; E - Sequence Decomposing](https://atcoder.jp/contests/abc134/tasks/abc134_e)  

**解説**  
seriesの色の塗り分けは広義単調増加が成立していると計算できる  

**解答**  
```python
N=int(input())
A=[]
for _ in range(N):
    A.append(int(input()))
import bisect
INF = float('inf')
dp = [-1]*(N)
for a in A:
    # 広義単調減少数列
    # 以下の処理は広義単調減少の数を求める
    idx = bisect.bisect_left(dp, a)
    dp[idx-1] = a
print(N-bisect.bisect_left(dp,0))
```

---

### 例; bisectでなくてflag管理で求める場合
**問題**  
[AtCoder Grand Contest 013; A - Sorted Arrays](https://atcoder.jp/contests/agc013/tasks/agc013_a)
**解説**  
部分部分で成立している単調増加の部分と広義単調減少の部分をflag管理で何個あるかカウントする必要がある  
なかなか一人では思いつかずスタックしてしまう  
**解答**  
```python
N = int(input())
A = list(map(int, input().split()))

ans = 1
flag = 0
now = A[0]
for i in A[1:]:
    if flag == 0 and now > i:
        flag = -1
    elif flag == 0 and now < i:
        flag = 1
    elif flag == -1 and now < i:
        ans += 1
        flag = 0
    elif flag == 1 and now > i:
        ans += 1
        flag = 0
    now = i
print(ans)
```
