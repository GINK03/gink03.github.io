---
layout: post
title: "javaメモ"
date: 2017-04-10
excerpt: "javaメモ(silver, gold)"
project: true
learning: true
tag: ["java", "oracle", "pearson VUE"]
comments: false
---

# Javaメモ(silver, gold)

## Java SE 11について 
 - **各資格レベル**
   - **2020年で国際的には廃止**
	 - `Java SE 11 Programmer 1(1Z0-815))`が`silver`に該当する
	 - `Java SE 11 Programmer 2(1Z0-816)`が`gold`に該当する
   - **2021年から一本化**
	 - `Java SE 11 Developer(1Z0-819)`
 - **受験の方法**
   - [oracle certview](https://certview.oracle.com/)にログイン
   - "manage exam at pearson VUE"で試験予約を行う

## package
 - パッケージは慣習としてドメイン名を逆にしたものを用いるが絶対ではない
 - すべてのクラスはパッケージに属するがパッケージを省略すると匿名パッケージになる
 - `java.lang`はimportしなくても使える
 - 同じパッケージもimportしなくても使える
 - 名前のあるpackageに無名のパッケージを暗黙的に読み込むことはできない

## main
 - public + staticである必要がある

## run
 - `java Test` or `java Test.java`
 - バックスラッシュでエスケープ
 - `"a "b` -> `a b`という文字列で解釈される

## types
 - `boolean`は存在するが`bool`はない
 - 数字リテラルの先頭で数字表現が変わる
   - `0b` -> 2進数
   - `0x` -> 16進数
   - `0` -> 8進数
 - `_`リテラル
   - 数字の先頭と最後はNG
   - 記号の前後はNG
 - `$`, `_`は変数として使える
 - `var`は型推論を行うがローカル変数の推論だけ(generic class等は作れない)
 - `StringBuilder`
   - デフォルトで16のバッファをもつ
 - `++`, `--`
   - その場でインクリメント、デクリメントする
 - 同値判定
   - `Object`の`equals`をオーバーライドする
   - `x.equals(null)`は`false`を保証する必要がある
   - `コンスタントプール`と`インスタンス`
	 - `==`では一致しないが、`equals`では一致する
 
## String
   - `String`は参照渡しにならずにコピーわたしになる?
   - `replace`はすべて変えるreplace all
   - `substring`がslice
   - `concat`が文字列連結
   - `100 + "yen"` -> `100yen`
   - リテラルのインスタンスで`==`で比較する際の挙動がだいぶ違う
   - C++の`char*`を取り出すには`.intern()`でアクセスする
	 - `.intern()`の内容は`==`で比較可能

## array
 - C++のようにスタックに初期化みたいなことはできない
   - 型だけを初期化はできる
 - リテラルだけでなく動的変数でもできる
 - ネストされた初期化は子だけサイズ宣言はできない
	 - NG -> `int[][] a = new int[][3]`
	 - OK -> `int[][] a = new int[3][]`
 - 初期化リスト
   - `String[] array = {1, 2, 3, 4}`

## swtich
 - OK
   - int以下の数字
   - enum
   - オブジェクト型
 - NG
   - long以上
   - boolean
 - `break;`を各ステートメントに記述しないと終了しない
 - リテラルのみ判別条件に使用可能

## for
 - `for(Object a: array)`のような表現のとき、`a`はコピー渡し

## equals
 - Objectのequals関数をオーバーライドして使用するがデフォルトの引数がobject型なので、型を固定するとオーバーロードになってしまい、適切に動作しない

## comparator
 - **クラス内実装**
   - 比較を行うもの
   - `left < right` -> `-1`のとき昇順
   - `left < right` -> `1`のとき降順
 - **クラス外実装**
   - `Collection.sort(arr, new Comparator<?>() { public int comprare(T t1, T t2) { return ... } })`

## arraylist, list
 - **基本**
   - forで回しているときにremoveするとそのオペレーションは問題がないが、次に呼び出すときに例外が出る
   - 初期化法
	 - `List.of(...)`
 - **Arraysクラス**
   - 初期化
	 - `Arrays.sort(ary1)`
	 - `Arrays.asList(...)`

## map
 - `null`もキーになる
 - **Mapクラス**
   - 初期化
	 - `Map<Integer, String> map = Map.of(1, "a", 2, "b")`

## treeset
 - 順位がある
 - `TreeMap<String, ?>`ならば、辞書順となる

## thread
 - **実行**
   - `Thread`を継承して`run`関数をオーバーライドして利用する
   - `Runnnable`インターフェースを継承してオーバーライドして利用する 
 - **実装**
   - `new Thread(new Runnnable() { public void run() { ... } }).start()`
   - `new Thread(() -> {...}).start()`
 - **members**
   - `getPriority()`
   - `setPriority(Integer)`
   - `getName()`
   - `sleep(long)`
   - `join()`
   - `yield()` -> 一時的に停止する
   - `interrupt()` -> 割り込みを入れる
 - **synchronized**
   - 関数の前に`synchronized`をつけることでオブジェクトが利用されたとき排他制御を行う

## lambda 
 - 実質final
   - 同じスコープの変数名と同じ変数をlambdaで使うことはできない
 - lambda内でlambdaを包括するscopeの変数にアクセスできるが変更はできない
 - `Predicate`
   - 評価専用関数でbool帰る
   - `or`, `and`で関数合成、 `negate()`で反転
 - `Supplier`
   - 引数を受け取らない
 - `Consumer`
   - 引数を受け取るが処理をするだけ
 - `return`の省略
   - ブレース記号を省略した場合に利用可能
 - `andThen`
   - 関数合成

## stream
 - `list.stream().map(...).forEach(...)`
 - **評価式**
   - `allMatch(...)`
   - `anyMatch(...)`
   - `noneMatch(...)` -> どの要素にもマッチしない
 - **reduce**
   - `Stream.of(10, 20, 30).reduce(0, (a, b) -> a + b)` -> 60
 - **toArray**
   - streamからarrayに変換
 - **operations**
   - `filter`
   - `distinct`
   - `limit`
   - `skip(long n)` -> n個を破棄した残り 
   - `map`
   - `flatMap`
   - `sorted` or `sorted(Comparetor<?>)`
   - `peek` -> consumerを期待して、streamを返す。デバッグ等 
 - **collectors**
   - `toList()`
   - `joining("hoge")`
   - `summingInt()` -> 合計値
   - `averageInt()` -> 平均値
   - `toSet()`
   - `toMap(f1, f2)`
   - `minBy`, `maxBy`
 - **parallelStream()**
   - パラレル化する

## optional
 - `null`の代替
 - **初期化**
   - `Optional<Integer> op = Optional.enmpty();`
   - `Optional<Integer> op = Optional.of(1);`
 - **check**
   - `op.isPresent()` -> 値があるとき
   - `op.isEmpty()` -> 値がないとき
 - **get**
   - `op.get()`
  
## interface
 - **通常**
   - C++のヘッダーファイルのようなもの
   - アクセス修飾子は無名だとpublicになる
   - interfaceに実装を入れるには`default`が必要
   - interfaceの方で受けるとき、実装があるsubclassまで探して実行
 - **function interface**
   - 単一の抽象メソッドを持つ必要がある
   - static, defaultのメソッドを抽象メソッドを定義可能
   - `@FunctionalInterface`をつけることで明示化可能

## inference type
 - **var**
   - OK
	 - `var a = "hello"`
	 - `var a = new int[]{10, 20}`
   - NG
	 - `var a = 100;`
	 - `var a = {10, 20}`

## abstract class
 - インスタンスを生成できない
 - すべての関数をoverrideする必要はない
 - overrideは戻り値の型を変えられる
 - 継承関係ではsubclassは継承元よりゆるいアクセス修飾子を定義できる

## inherit
 - subclassでコンストラクタで`super()`を省略しても`super()`がコンパイラで挿入される
 - シグネチャは同様のものが継承される

## overloading
 - 入力がどうなっても良いが、出力の型を変えることができない
 - シグネチャ(protected, private, public)は変えることはできない

## constructor
 - publicなコンストラクタは外部から関数として呼び出すことができる
 - void, intとかの戻り値をつけると通常関数として解釈される
 - `this(...)`で自インスタンスのコンストラクタを呼び出せる
 - コンストラクタ内部で別のコンストラクタを呼ぶときは必ず最初に記述する

## initialization
 - コンストラクタの前に置く
 - コンストラクタの前に実行される処理
 - static classではインスタンスを作らないと実行されない

## generics 
 - `class Hoge<T> { private T var1; ... }`のように書いて型パラメータを抽象化する
 - 使用する際、`<?>`のように記述することでその部分を再抽象化できる

## exceptions
 - **illigal**
   - 到達不能なcacheブロックが存在するとき
   - `try-cache-finally`は順序違反 
 - **return**
   - `cache`ステートメントに`return`が存在しても`finally`実行後に実行される
   - `cache`と`finally`どちらにも`return`があるとき、最後に実行された`return`の値が戻る
 - **種類**
   - *非検査例外*
	 - `RuntimeException`は非検査例外で明示的に関数に示さなくてもいい
	 - `ArrayIndexOutOfBounds`, `ArrayStoreException`, `ClassCastException`
   - *検査例外*
	 - 検査例外はJVM以外の外的要因でハンドルされるもの
	 - 必ず処理が求められる
	 - 例外とは別に`Error`というものがある
	 - `AssertionError`, `StackOverFlow`, `NoClassDefFoundError`, `IOException`, `FileNotFoundException`, `ParseException`, `SQLException`
 - **variance**
   - `catch(NumberFormatException | ArithmeticException e) { ... }`のように併記できる
 - **throws**
   - 関数の後ろに定義することで例外が発生したときに関数の呼び出し元に通知する
   - テクニックの一つとしてthrowを条件分岐するrethrowというものがある
 - **try-with-resourecs**
   - `try(MyResource obj = new MyResource()){ ... }`のような書き方のものでリソースを最後にclose()するのでリークしない
 - **assert**
   - 真値を返さないと`Error`を送出する
   - `assert( something > 0): "エラーです"`
   - `java -ea Main`のように実行することで有効化できる


## IO
 - **種類**
   - `FileInputStream` -> ファイルからバイト単位で読み込み
   - `FileOutputStream` -> ファイルからバイト単位で書き込み
   - `DataInputStream` -> 基本データを読み込む
   - `DataOutputStream` -> 基本データを書き込む
   - `FileReader` -> char単位で読み込む
   - `FileWriter` -> char単位で書き込む
   - `BufferReader` -> char単位でバッファリングして読み込む
   - `BufferWriter` -> char単位でバッファリングして書き込む

## nio
 - PythonのPathクラスのようなもの
 - pathインスタンス
   - `Path.get("something string path")`
 - `Files`による操作
   - `Files.createDirectory(path)`
   - `Files.createDirectories(path)`
   - `Files.deleteIfExists(path)`
   - `Files.delete(path)`
   - `Files.copy(path1, path2, OPTION)`
   - `Files.move(path1, path2, OPTION)`
   - `Files.getAttribute(path, "OPTION")` -> "size", "creationTime"等
   - `Files.walk(path).filter(s -> s.toString().endsWith(".jpg"))`


## jdbc
 - **syntax**
   - `jdbc:<protocol>:<name>`
   - `jdbc:mysql://localhost:3306/golddb`
 - **drivermanager**
   - `con = DriverManager.getConnection(usr, "root", "password")` 
 - **statement**
   - `stmt = con.prepareStatement(sql)`
 - **cursol**
   - `rs = stmt.exrcuteQuery()`
   - `while(rs.next()) {  rs.getInt(1), rs.getString(2) }`
 - **secure coding**
   - update等を行うときに不正な値が入らないようにする
   - アップデートしたい箇所は`?`とするSQLを用意する
   - `PreparedStatement stmt = connection.prepareStatement(SQL)`
   - `stmt.setString(1, "パスワード")`のようにして値を入れる
   - `stmt.executeUpdate()`
 - **normalizer**
   - `Normalizer.normalize("正規化したいデータ", From.NFKC)`

## serialize
 - `Serializable`をimplementsする
 - `ObjectOutputStream`で`oos.writeObjcet(instance)`のように書き込む
 - `ObjectInputStream`で`(Inatance)ois.readObject()`で読み込む

## modules
 - `module-info.java`に記述
   - `exports ${PACKAGE_NAME}`
   - `requires ${DEP}`
	 - `requires transitive ${DEP}` -> 階層構造の自分を依存するmoduleに全てに伝搬させる
   - `privides ${SERVICE} with ${SERVICE_PROVIDER}`
   - `uses ${SERVICE}`
 - モジュールを含めて実行
   - `java --module-path $DIR -m ${MAIN_CLASS}/${PACKAGE_PATH}`
 - デフォルトで組み込まれるmodule
   - `java.base`
 - モジュールを表示
   - `jmod describe`
   - `java --describe-module `
 - コンパイル時に一時的にmoduleを追加
   - `java ... --add-exports=... ...`

## annotations
 - **種類**
   - `@Override` -> 明示的にオーバーライド
   - `@FunctionalInterface` -> 関数型のインターフェース
   - `@Deprecated` -> 非推奨
   - `@SuprressWarnings` -> コンパイラ警告無効
	 - `@suprresswarnings(value = {"..."})`
	 - `@suprresswarnings(value = {"...", "..."})`
	 - `@suprresswarnings({"...", "..."})`
   - `@SafeVarargs` -> 可変長引数の警告無効
 - **カスタム**
   - `@interface`
   - クラスのように定義する
   - 抽象メソッドが変数のような役割
   - enumも指定可能
 - **メタアノテーション**
   - `@Documented` -> Javadocに出力
	 - `javadoc -d *.java`
   - `@Targget` -> アノテーション要素を限定
   - `@Retention` -> アノテーションをクラスファイルまで持ち込むか
   - `@Inherit` -> サブクラスにも引き継ぐ
   - `@Repeatable` -> 複数回適応
