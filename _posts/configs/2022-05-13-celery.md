---
layout: post
title: "celery"
date: "2022-05-13"
excerpt: "celeryの使い方"
project: false
config: true
tag: ["python", "celery", "task queue", "async"]
comments: false
---

# celeryの使い方　

## 概要
 - celeryはサーバクライアントモデルのrpcとみなせる
 - 通信のバックエンドにはredisなどを利用できる
 - 実行にはceleryのタスクを実行するサーバサイドのプロセスと、そのタスクをリモートで呼び出すクライアントのプロセスが必要

## インストール

```console
$ python3 -m pip install celery
```

## サーバサイドの実行
 - `task.py`があるときに、同じディレクトリで`$ celery -A tasks worker --loglevel=info`
 - クライアントのプロセスが立ち上がる前にかならずサーバサイドが立ち上がっていること
 - サーバとクライアントのパッケージ粒度と名前空間が同じであること
 - ディレクトリ`bin`の中にある、`bin/tasks.py`を実行するには`$ celery -A bin.tasks worker --loglevel=info`
 - サーバサイドで関数の登録が失われたり、不整合が起きるときは redisを再起動
 - concurrency数の上限を設定
   - `$ celery -A bin.task worker --concurrency=1 --loglevel=CRITICAL`

### サーバサイドのコードの例

```python
from celery import Celery

BROKER_URL = 'redis://localhost:6379/0'
BACKEND_URL = 'redis://localhost:6379/1'

app = Celery('tasks', broker=BROKER_URL, backend=BACKEND_URL)

@app.task
def add(x, y):
    return x + y
```

## クライアントサイドの実行
 - flaskなどからも実行可能である
 - サーバのコードとクライアントのコードはパッケージ粒度と名前空間が同じであること

### クライアントサイドのコードの例

```python
from tasks import add
import time
result = add.delay(4, 4) # addの関数の呼び出し
time.sleep(0.1) # celeryのジョブの反映を少しだけ待つ
print(result.ready()) # True
print(result.status) # SUCCESS
print(result.get()) # 8
```
